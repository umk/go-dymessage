package typecod

import (
	"fmt"

	"github.com/golang/protobuf/ptypes"
	"github.com/golang/protobuf/ptypes/any"

	"github.com/umk/go-dymessage"
	"github.com/umk/go-dymessage/protobuf"
)

// Provides the fast lookup of the message definitions.
type TypeCache struct {
	reg *dymessage.Registry
	// The mapping from the qualified name of the messages to its definitions.
	types map[string]*dymessage.MessageDef
}

func NewTypeCache(reg *dymessage.Registry) *TypeCache {
	types := make(map[string]*dymessage.MessageDef)
	for _, def := range reg.Defs {
		qname := getQualifiedName(def)
		types[qname] = def
	}
	return &TypeCache{reg: reg, types: types}
}

// EncodeAny encodes provided dynamic entity to Protocol Buffer's Any type. If
// the type of the entity doesn't belong to the registry, provided during
// creation of Encoder, the method will panic.
func EncodeAny(value *dymessage.Entity, cache *TypeCache) (*any.Any, error) {
	def := cache.reg.GetMessageDef(value.DataType)
	if data, err := protobuf.Encode(value, def); err != nil {
		return nil, err
	} else {
		return &any.Any{
			TypeUrl: "type.googleapis.com/" + getQualifiedName(def),
			Value:   data,
		}, nil
	}
}

// EncodeAny encodes provided Protocol Buffer's Any type to dynamic entity. If
// the type URL of provided value doesn't represent a type, known to Encoder,
// the method will return an error.
func DecodeAny(value *any.Any, cache *TypeCache) (*dymessage.Entity, error) {
	if name, err := ptypes.AnyMessageName(value); err != nil {
		return nil, err
	} else if def, ok := cache.types[name]; !ok {
		return nil, fmt.Errorf("dymessage: type %q could not be found", name)
	} else {
		return protobuf.DecodeNew(value.Value, def)
	}
}

// getQualifiedName gets the qualified name of dynamic type as it would be
// generated by a Protocol Buffers code on the client side when using the
// the .proto definitions, autogenerated from dynamic message definitions.
func getQualifiedName(def *dymessage.MessageDef) string {
	if len(def.Namespace) == 0 {
		return def.Name
	} else {
		return def.Namespace + "." + def.Name
	}
}
